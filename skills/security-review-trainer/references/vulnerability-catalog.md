# Vulnerability Catalog

Reference catalog for challenge construction. Maps OWASP Top 10 (2021) categories to
concrete vulnerability patterns at each difficulty level, documents common false positive
patterns, and describes vulnerability interaction chains.

This catalog is for the trainer, not the student. Do not share this document with the
user during a session -- it would undermine the discovery-based learning model.

---

## OWASP Top 10 Categories by Difficulty Level

### A01:2021 -- Broken Access Control

The most prevalent category in real-world applications. Failures in enforcing that users
cannot act outside their intended permissions.

**Level 1 -- Obvious:**
Missing authentication check entirely. A sensitive endpoint (e.g., `/admin/users`) has no
middleware or guard verifying that the caller is authenticated or authorized. The handler
directly processes the request. Findable by noticing the absence of any auth-related code
in the handler or route definition.

**Level 2 -- Standard:**
Authorization check exists but uses client-supplied role information. The code reads a
`role` field from the request body or a non-validated cookie to decide access. The check
is present, so a cursory review sees "auth logic" and moves on, but the data source is
attacker-controlled.

**Level 3 -- Context-Dependent:**
IDOR through predictable identifiers. The endpoint `/api/invoices/{id}` uses a sequential
integer ID. The authorization middleware verifies the user is authenticated but does not
verify the user owns the requested invoice. Requires understanding that authentication
(who are you?) is not authorization (are you allowed to access this resource?).

**Level 4 -- Subtle:**
Horizontal privilege escalation through a batch operation. A single-item endpoint correctly
checks ownership, but the batch endpoint (`/api/invoices/export?ids=1,2,3,4`) iterates
over IDs without per-item authorization. The developer assumed "if they can access the
batch endpoint, they can access all items in the batch." Requires reading both the single
and batch code paths.

**Level 5 -- Architectural:**
Confused deputy through a microservice proxy. Service A is a gateway that authenticates
users. Service B performs operations using its own service account credentials. Service A
forwards user requests to Service B, which trusts that Service A validated authorization.
But Service A only validates authentication, not resource-level authorization. An
authenticated user can request operations on any resource because Service B's trust in
Service A is overbroad. Requires understanding the trust model between services.

---

### A02:2021 -- Cryptographic Failures

Failures related to cryptography (or lack thereof) that lead to exposure of sensitive data.

**Level 1 -- Obvious:**
Passwords stored in plaintext or with a fast hash (MD5, SHA-1). The code inserts
`hash(password)` using a non-cryptographic or deprecated hash function directly into the
database. Recognizable by the hash function name.

**Level 2 -- Standard:**
Encryption with a hardcoded key or IV. The code uses AES encryption, which looks correct
on the surface, but the key is a string literal in the source code. Or the IV is static
(the same value for every encryption operation), which defeats the purpose of the IV.

**Level 3 -- Context-Dependent:**
Sensitive data transmitted over an internal network without TLS. The code makes HTTP (not
HTTPS) calls to an internal service, passing authentication tokens or PII. The developer
assumed the internal network is trusted. Requires understanding that "internal" does not
mean "safe" -- network segmentation is not a substitute for transport encryption.

**Level 4 -- Subtle:**
JWT with algorithm confusion. The code verifies JWTs and supports both HMAC (symmetric)
and RSA (asymmetric). An attacker can craft a token using the HMAC algorithm with the
RSA public key as the HMAC secret. If the verification code does not pin the expected
algorithm, it accepts the forged token. Requires understanding JWT verification internals.

**Level 5 -- Architectural:**
Insufficient entropy in security-critical random values. The code generates password reset
tokens using a PRNG seeded with the current timestamp. The tokens pass length and character
requirements but are predictable to an attacker who knows the approximate generation time.
The code looks correct because it produces random-looking output. Requires understanding
the difference between randomness and unpredictability.

---

### A03:2021 -- Injection

Untrusted data sent to an interpreter as part of a command or query.

**Level 1 -- Obvious:**
SQL query built with string concatenation using user input. The code constructs a query
by directly interpolating user-supplied values into the SQL string. Recognizable by the
concatenation pattern adjacent to a query execution call.

**Level 2 -- Standard:**
XSS in an unexpected output context. User input is HTML-escaped for display in a page
body but is also inserted into a JavaScript context (e.g., inside a `<script>` tag or
an `onclick` attribute) where HTML encoding is insufficient. Requires understanding
that encoding is context-dependent.

**Level 3 -- Context-Dependent:**
ORM injection through raw query fragments. The code uses an ORM for most queries but
drops to a raw SQL fragment for a complex WHERE clause or ORDER BY with user-controlled
column names. The ORM usage throughout the file creates a false sense of safety. Requires
tracing which parts of the query are parameterized and which are not.

**Level 4 -- Subtle:**
Second-order injection. User input is safely stored in the database (properly
parameterized on insert). Later, a different code path reads that stored value and uses
it unsafely -- constructing a query, command, or template with the stored value without
parameterization. The original input path is safe; the vulnerability is in the read path.
Requires tracing data flow across store-then-retrieve patterns.

**Level 5 -- Architectural:**
Template injection through a user-customizable notification system. Users can define
notification templates with placeholder variables. The template engine is powerful enough
to allow expression evaluation or object traversal. A malicious template can escape the
intended variable substitution sandbox and access internal objects or execute arbitrary
expressions. Requires understanding template engine capabilities and sandbox limitations.

---

### A04:2021 -- Insecure Design

Broad category for design-level flaws that cannot be fixed by implementation alone.

**Level 1 -- Obvious:**
No rate limiting on authentication endpoints. The login endpoint processes unlimited
attempts per second with no lockout, delay, or CAPTCHA. Brute force is trivial.

**Level 2 -- Standard:**
Security questions as password recovery mechanism. The code implements "forgot password"
using security questions whose answers are often publicly available or guessable (mother's
maiden name, first pet, high school).

**Level 3 -- Context-Dependent:**
Missing re-authentication for sensitive operations. A user can change their email address
(which is also their login identifier) or enable/disable 2FA without re-entering their
current password. If the session is hijacked, the attacker can lock out the real user.
Requires reasoning about session compromise scenarios.

**Level 4 -- Subtle:**
Race condition in a business operation that should be atomic. A balance check and deduction
happen in separate database operations without a transaction or row-level lock. Two
concurrent requests can both pass the balance check and both deduct, allowing overdraft.
Requires understanding concurrency and atomicity.

**Level 5 -- Architectural:**
Implicit trust between microservices without mutual authentication. Service A calls
Service B's internal API, which has no authentication because "only internal services
call it." Any compromised service or network-adjacent attacker can call Service B directly.
The design assumes network perimeter equals trust boundary.

---

### A05:2021 -- Security Misconfiguration

Insecure default configurations, incomplete configurations, open cloud storage, verbose
error messages, unnecessary features enabled.

**Level 1 -- Obvious:**
Debug mode enabled in production configuration. Stack traces, internal paths, and
configuration details are returned in error responses. The `DEBUG = True` or equivalent
is visible in the configuration file.

**Level 2 -- Standard:**
Overly permissive CORS configuration. The code sets `Access-Control-Allow-Origin: *` on
endpoints that return sensitive data or accept state-changing requests. Or the code
reflects the Origin header without validation.

**Level 3 -- Context-Dependent:**
Default credentials left in a configuration or initialization script. The application
creates a default admin account with a well-known password during setup. The code that
creates this account exists but the code that forces a password change on first login
does not. Requires reading the initialization flow, not just the runtime code.

**Level 4 -- Subtle:**
XML parser configured to process external entities (XXE). The code parses user-supplied
XML with a parser whose default configuration allows external entity resolution. The
vulnerability is not in the code logic but in the parser configuration (or lack thereof).
Requires knowing which parser defaults are dangerous.

**Level 5 -- Architectural:**
Cloud storage bucket with public read access used for both public assets and private
uploads. The infrastructure code creates one bucket with public access for serving static
content. A later change stores user-uploaded documents in the same bucket. The
misconfiguration is not in the application code but in the infrastructure definition.
Requires reading the infrastructure-as-code alongside the application code.

---

### A06:2021 -- Vulnerable and Outdated Components

Using components with known vulnerabilities. Less relevant for code review training but
included for completeness.

**Level 3 -- Context-Dependent:**
Dependency pinned to a version with a known CVE. A `requirements.txt`, `package.json`, or
equivalent specifies a library version that has a published security advisory. Requires
awareness of the vulnerability landscape for common libraries.

**Level 5 -- Architectural:**
Dependency confusion through internal package naming. A private package shares a name with
a public registry package. If the build system checks the public registry first (or
additionally), an attacker can publish a malicious package with a higher version number.
Requires understanding package resolution order and supply chain attack vectors.

---

### A07:2021 -- Identification and Authentication Failures

Weaknesses in authentication mechanisms, session management, or identity verification.

**Level 1 -- Obvious:**
No password complexity requirements. The registration endpoint accepts single-character
passwords. No minimum length, no complexity rules, no check against breach databases.

**Level 2 -- Standard:**
Session tokens not invalidated on logout or password change. The logout endpoint clears
the client-side cookie but does not invalidate the session on the server. A captured
session token remains valid indefinitely.

**Level 3 -- Context-Dependent:**
Username enumeration through differential responses. The login endpoint returns "invalid
username" vs "invalid password" as distinct error messages, or responds with measurably
different timing for existing vs non-existing users. Requires understanding information
leakage through error handling.

**Level 4 -- Subtle:**
Timing side-channel in password comparison. The code compares the submitted password hash
against the stored hash using a standard string equality operator that short-circuits on
the first different byte. An attacker can determine the correct hash one byte at a time
by measuring response times. Requires understanding timing attacks.

**Level 5 -- Architectural:**
OAuth implementation that does not validate the `state` parameter, enabling CSRF-based
account linking. An attacker initiates OAuth flow, captures the callback URL with their
authorization code, and tricks a victim into visiting it. The victim's account is now
linked to the attacker's external identity. Requires understanding the OAuth flow and the
role of the state parameter.

---

### A08:2021 -- Software and Data Integrity Failures

Assumptions about software updates, critical data, or CI/CD pipelines without verifying
integrity.

**Level 2 -- Standard:**
Deserialization of untrusted data. The code deserializes objects from user-supplied input
(cookies, API parameters, message queues) using a format that supports arbitrary object
instantiation (e.g., Java ObjectInputStream, Python's pickle module, PHP unserialize).
Recognizable by the deserialization function name and the input source.

**Level 4 -- Subtle:**
CI/CD pipeline that runs code from pull requests before merge approval. The build
configuration runs tests from the PR branch, which can include arbitrary code in test
fixtures or build scripts. A malicious PR can exfiltrate secrets available in the CI
environment. Requires understanding CI/CD security boundaries.

---

### A09:2021 -- Security Logging and Monitoring Failures

Insufficient logging, monitoring, or alerting to detect or respond to breaches.

**Level 3 -- Context-Dependent:**
Authentication failures not logged, or logged without sufficient detail for investigation.
The code catches authentication exceptions but either swallows them silently or logs only
a generic message without the attempted username, source IP, or timestamp. Requires
understanding what logs are needed for incident response.

**Level 4 -- Subtle:**
Sensitive data included in logs. The code logs request payloads for debugging, and those
payloads include passwords, tokens, or PII. The logging code looks correct (it logs useful
information) but creates a secondary exposure vector through log storage and aggregation.
Requires reasoning about where log data ends up.

---

### A10:2021 -- Server-Side Request Forgery (SSRF)

The application fetches a remote resource based on user-supplied input without validating
the destination.

**Level 2 -- Standard:**
Direct SSRF. A webhook, URL preview, or file import feature takes a URL from user input
and fetches it server-side. No validation on the URL scheme or destination host. An
attacker can target internal services (cloud metadata endpoints, internal databases,
caches).

**Level 4 -- Subtle:**
SSRF through redirect chains. The code validates that the user-supplied URL points to an
allowed external host. But the allowed host returns a 302 redirect to an internal IP. The
HTTP client follows the redirect without re-validating the destination. Requires
understanding that URL validation must occur after redirect resolution.

**Level 5 -- Architectural:**
SSRF through a PDF rendering service. The application generates PDFs from HTML templates.
User-controlled content is included in the HTML (e.g., an invoice with user-provided
addresses). The PDF renderer fetches resources referenced in the HTML (images, stylesheets).
A malicious user injects an image tag pointing to an internal service URL. The PDF
renderer, running on the internal network, fetches the internal resource and embeds the
response in the PDF. Requires understanding the rendering pipeline and its network context.

---

## Common False Positive Patterns

These are code patterns that look vulnerable to an inexperienced reviewer but are actually
safe. Include these in challenges to train precision.

### Parameterized Queries With Misleading Variable Names

A variable named `query` or `sql` that holds a parameterized query string with placeholder
markers. The actual parameter binding happens in the execution call. Looks like string
concatenation at first glance but is safe.

### Intentionally Public Endpoints

Not every endpoint needs authentication. A health check (`/health`), a public product
catalog (`/api/products`), or a login endpoint are legitimately unauthenticated. Flagging
these as "missing auth" is a false positive that reveals a lack of threat modeling.

### Constant-Time Comparison Functions

A hash comparison using `hmac.compare_digest()`, `crypto.timingSafeEqual()`, or equivalent
library function. These look like simple equality checks but are specifically designed to
prevent timing attacks. Flagging them as timing-vulnerable is a false positive.

### Encoded Output in the Correct Context

User input that is HTML-encoded and rendered in an HTML body context, or URL-encoded and
placed in a URL context. The encoding matches the output context, making it safe despite
the presence of user-controlled content.

### Bcrypt/Scrypt/Argon2 With Default Rounds

Modern password hashing functions with their default work factor. The defaults are chosen
by cryptographers to be secure. Flagging `bcrypt.hash(password)` as "needs more rounds"
is a false positive unless the work factor is explicitly set to an unusually low value.

### Internal Service Communication Over Private Networks

HTTP calls between services within a Kubernetes cluster using ClusterIP services. While
TLS would be better (defense-in-depth), this is not inherently exploitable in the same way
as public-facing HTTP. Context determines severity: internal tooling traffic vs.
transmitting credentials.

---

## Vulnerability Interaction Patterns

These describe how two individually lower-severity vulnerabilities combine to create a
higher-severity outcome. Plant these at Level 4+ to teach compound vulnerability reasoning.

### Information Disclosure + Broken Access Control

An endpoint leaks internal object IDs (e.g., sequential user IDs in an API response).
Another endpoint has an IDOR vulnerability using those IDs. Neither is critical alone: the
information disclosure reveals IDs but not data; the IDOR requires valid IDs. Together, the
information disclosure enables exploitation of the IDOR. Combined severity: high to critical.

### SSRF + Internal Service Without Authentication

A limited SSRF allows the attacker to reach internal hostnames but not exfiltrate response
data directly. An internal admin service has no authentication because it is "only reachable
internally." The SSRF can invoke admin operations on the internal service. Individually:
medium SSRF (no direct data exfiltration), low misconfiguration (internal-only service).
Combined: critical (unauthenticated admin access through SSRF).

### XSS + Missing CSRF Protection

A stored XSS vulnerability in a low-privilege area (e.g., user profile bio). A sensitive
operation (e.g., password change, admin action) lacks CSRF protection but requires an
active session. The XSS can submit the sensitive operation request with the victim's session
cookie. Individually: medium XSS (in a bio field), medium CSRF (requires active session).
Combined: high to critical (account takeover through chained XSS/CSRF).

### Race Condition + Insufficient Logging

A race condition allows double-spending in a financial operation. The logging system records
the final state but not the intermediate states or the timing of concurrent requests. The
race condition is exploitable, and the logging gap means it is undetectable. Individually:
high (race condition), low (logging gap). Combined: critical (exploitable and invisible).

### Username Enumeration + Credential Stuffing

The login endpoint reveals whether a username exists through error message differentiation.
The same endpoint has no rate limiting. An attacker first enumerates valid usernames, then
targets those accounts with credential stuffing using breach databases. Individually:
low (username enumeration), medium (no rate limiting). Combined: high (targeted credential
stuffing with known-valid usernames).
